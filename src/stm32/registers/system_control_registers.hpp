#pragma once

#include <cstdint>

#include "../utils/general.hpp"

namespace stm32::rg
{
/**
 * Specifies the ID number of the processor core, the version number of the processor core and the implementation
 * details of the processor core.
 *
 * @note This register is available in all processor configurations.
 */
DEFINE_REG(CpuIdBaseRegister, {
    uint8_t REVISION : 4;  ///< bits[3:0]
                           ///< Indicates patch release: 0x1 = Patch 1.

    uint16_t PARTNO : 12;  ///< bits[15:4]
                           ///< Indicates part number: 0xC24 = Cortex-M3

    uint8_t constant : 4;  ///< bits[19:16]
                           ///< Reads as 0xF

    uint8_t VARIANT : 4;  ///< bits[23:20]
                          ///< Indicates processor revision: 0x0 = Revision 0

    uint8_t IMPLEMENTER : 8;  ///< bits[31:24]
                              ///< Indicates implementer: 0x41 = ARM
});

/**
 * Provides software control of the NMI, PendSV, and SysTick exceptions, and provides interrupt status information.
 */
DEFINE_REG(InterruptControlAndStateRegister, {
    uint16_t VECTACTIVE : 9;  ///< bits[8:0], read only for memory
                              ///< The exception number of the current executing exception. A value of 0 indicates that
                              ///< the processor is in Thread mode.

    RESERVE(2);  ///< bits[10:9]

    bool RETTOBASE : 1;  ///< bit[11], read only for memory
                         ///< In Handler mode, indicates whether there is an active exception other than the exception
                         ///< indicated by the current value of the IPSR
                         ///<
                         ///< If true there is no active exception other than any exception shown by IPSR, there is an
                         ///< active exception other than the exception shown by IPSR otherwise
                         ///<
                         ///< In Thread mode the value of this bit is UNKNOWN


    uint16_t VECTPENDING : 9;  ///< bits[20:12], read only for memory
                               ///< The exception number of the highest priority pending and enabled interrupt. A value of
                               ///< 0 indicates that there is no pending exception
                               ///<
                               ///< If DHCSR.C_MASKINTS is set, then PendSV, SysTick, and configurable external interrupts
                               ///< are masked and will not be shown as pending in VECTPENDING

    RESERVE(1);  ///< bit[21]

    bool ISRPENDING : 1;  ///< bit[22], read only for memory
                          ///< Indicates whether an external interrupt, generated by the NVIC, is pending

    bool ISRPREEMPT : 1;  ///< bit[23], read only for memory
                          ///< Indicates whether a pending exception will be serviced on exit from debug halt state

    RESERVE(1);  ///< bit[24]

    bool PENDSTCLR : 1;  ///< bit[25], write only for memory
                         ///< Removes the pending status of the SysTick exception if true, has no effect otherwise

    bool PENDSTSET : 1;  ///< bit[26]
                         ///< On writes, sets the SysTick exception as pending. On reads, indicates the current state of
                         ///< the exception

    bool PENDSVCLR : 1;  ///< bit[27], write only for memory
                         ///< Removes the pending status of the PendSV exception if true, has no effect otherwise

    bool PENDSVSET : 1;  ///< bit[28]
                         ///< On writes, sets the PendSV exception as pending. On reads, indicates the current state of
                         ///< the exception
                         ///< Make PendSV exception pending if true, has no effect otherwise

    RESERVE(2);  ///< bits[30:29]

    bool NMIPENDSET : 1;  ///< bit[31]
                          ///< On writes, makes the NMI exception active if true, has no effect otherwise
});

/**
 * Holds the vector table address.
 *
 * @note One or two of the high-order bits of the TBLOFF field can be implemented as RAZ/WI, reducing the supported
 * address range. For example, if two bits are implemented as RAZ/WI, then TBLOFF[29:7] defines bits[29:7] of the
 * address.
 *
 * @note Software can write all 1s to the TBLOFF field and then read the register to find the maximum supported offset
 * value.
 */
DEFINE_REG(VectorTableOffsetRegister, {
    RESERVE(7);  ///< bits[6:0]

    uint32_t TBLOFF : 25;  ///< bits[31:7]
                           ///< Bits[31:7] of the vector table address
});

/**
 * Sets or returns interrupt control data.
 */
DEFINE_REG(ApplicationInterruptAndResetControlRegister, {
    bool VECTRESET : 1;  ///< bit[0], write only for memory
                         ///< Writing 1 to this bit causes a local system reset
                         ///< The effect of writing a 1 to this bit if the processor is not halted in Debug state is
                         ///< UNPREDICTABLE
                         ///< When the processor is halted in Debug state, if a write to the register writes a 1 to both
                         ///< VECTRESET and SYSRESETREQ, the behavior is UNPREDICTABLE.

    bool VECTCLRACTIVE : 1;  ///< bit[0], write only for memory
                             ///< Writing 1 to this bit clears all active state information for fixed and configurable
                             ///< exceptions.
                             ///< This includes clearing the IPSR to zero
                             ///< The effect of writing a 1 to this bit if the processor is not halted in Debug state is
                             ///< UNPREDICTABLE.

    bool SYSRESETREQ : 1;  ///< bit[2]
                           ///< Writing 1 to this bit asserts a signal to the external system to request a Local reset.
                           ///< A Local or Power-on reset clears this bit to 0.

    RESERVE(5);  ///< bits[7:3]

    uint8_t PRIGROUP : 3;  ///< bits[10:8]
                           ///< Priority grouping, indicates the binary point position.
                           ///< This field resets to 0b000

    RESERVE(4);  ///< bits[14:11]

    bool ENDIANNESS : 1;  ///< bit[15], read only for memory
                          ///< Indicates the memory system endianness
                          ///< This bit is static or configured by a hardware input on reset.

    RESERVE(16);  ///< bits[31:16]

    // Vector key
    // uint16_t VECTKEY : 16 / uint16_t VECTKEYSTAT : 16
    // Register writes must write 0x05FA to this field, otherwise the write is ignored
    // Register reads returns 0xFA05
});

/**
 * Sets or returns system control data
 */
DEFINE_REG(SystemControlRegister, {
    RESERVE(1);  ///< bit[0]

    bool SLEEPONEXIT : 1;  ///< bit[1]
                           ///< Determines whether, on an exit from an ISR that returns to the base level of execution
                           ///< priority, the processor enters a sleep state
                           ///< false - do not enter sleep state
                           ///< true - enter sleep state

    bool SLEEPDEEP : 1;  ///< bit[2]
                         ///< Provides a qualifying hint indicating that waking from sleep might take longer. An
                         ///< implementation can use this bit to select between two alternative sleep states:
                         ///< false - selected sleep state is not deep sleep.
                         ///< true - selected sleep state is deep sleep.
                         ///< Details of the implemented sleep states, if any, and details of the use of this bit, are
                         ///< IMPLEMENTATION DEFINED.
                         ///< If the processor does not implement a deep sleep state then this bit can be RAZ/WI

    RESERVE(1);  ///< bit[3]

    bool SEVONPEND : 1;  ///< bit[4]
                         ///< Determines whether an interrupt transition from inactive state to pending state is a wakeup
                         ///< event:
                         ///< false - transitions from inactive to pending are not wakeup events
                         ///< true - transitions from inactive to pending are wakeup events

    RESERVE(27);  ///< bits[31:5]
});

/**
 * Sets or returns configuration and control data, and provides control over caching and branch prediction.
 */
DEFINE_REG(ConfigurationAndControlRegister, {
    bool NONBASETHRDENA : 1;  ///< bit[0]
                              ///< Controls whether the processor can enter Thread mode with exceptions active:
                              ///< false - any attempt to enter Thread mode with exceptions active faults.
                              ///< true - The processor can enter Thread mode with exceptions active because of a
                              ///< controlled return value

    bool USERSETMPEND : 1;  ///< bit[1]
                            ///< Controls whether unprivileged software can access the STIR:
                            ///< false - unprivileged software cannot access the STIR.
                            ///< true - unprivileged software can access the STIR.

    RESERVE(1);  ///< bit[2]

    bool UNALIGN_TRP : 1;  ///< bit[3]
                           ///< Controls the trapping of unaligned word or halfword accesses:
                           ///< false - trapping disabled
                           ///< true - trapping enabled
                           ///< Unaligned load-store multiples and word or halfword exclusive accesses always fault

    bool DIV_0_TRP : 1;  ///< bit[4]
                         ///< Controls the trap on divide by 0:
                         ///< false - trapping disabled
                         ///< true - trapping enabled

    RESERVE(3);  ///< bits[7:5]

    bool BFHFNMIGN : 1;  ///< bit[8]
                         ///< Determines the effect of precise data access faults on handlers running at priority -1 or
                         ///< priority -2:
                         ///< false - precise data access fault causes a lockup
                         ///< true - handler ignores the fault

    bool STKALIGN : 1;  ///< bit[9]
                        ///< Determines whether the exception entry sequence guarantees 8-byte stack frame alignment,
                        ///< adjusting the SP if necessary before saving state:
                        ///< false - guaranteed SP alignment is 4-byte, no SP adjustment is performed
                        ///< true - 8-byte alignment guaranteed, SP adjusted if necessary.
                        ///< The reset value of this bit is 1

    RESERVE(6);  ///< bits[15:10]

    bool DC : 1;  ///< bit[16]
                  ///< Cache enable bit. This is a global enable bit for data and unified caches. The possible values
                  ///< of this bit are:
                  ///< false - data and unified caches disabled
                  ///< true - data and unified caches enabled
                  ///<
                  ///< If the system does not implement any data or unified caches that can be accessed by the
                  ///< processor at any level of the memory hierarchy, this bit is RAZ/WI
                  ///<
                  ///< If the system implements any data or unified caches that can be accessed by the processor
                  ///< then it must be possible to disable them by setting this bit to false

    bool IC : 1;  ///< bit[17]
                  ///< Instruction cache enable bit. This is a global enable bit for instruction caches. The possible
                  ///< values of this bit are:
                  ///< false - instruction caches disabled
                  ///< true - instruction caches enabled
                  ///<
                  ///< If the system does not implement any instruction caches that can be accessed by the
                  ///< processor at any level of the memory hierarchy, this bit is RAZ/WI.
                  ///<
                  ///< If the system implements any instruction caches that can be accessed by the processor then
                  ///< it must be possible to disable them by setting this bit to false.

    bool BP : 1;  ///< bit[18]
                  ///< Branch prediction enable bit. The possible values of this bit are:
                  ///< false - program flow prediction disabled.
                  ///< true - program flow prediction enabled.
                  ///<
                  ///< Setting this bit to 1 enables branch prediction, also called program flow prediction
                  ///<
                  ///< If program flow prediction cannot be disabled, this bit is RAO/WI.
                  ///<
                  ///< If the implementation does not support program flow prediction, this bit is RAZ/WI.

    RESERVE(13);  ///< bits[31:19]
});

/**
 * Sets or returns priority for system handlers
 */
DEFINE_REG(SystemHandlerPriorityRegister, { uint8_t PRI[4]; });

/**
 * Controls and provides the active and pending status of system exceptions.
 *
 * @note Exception processing automatically updates the SHCSR fields. However, software can write to the register to add
 * or remove the pending or active state of an exception. When updating the SHCSR, ARM recommends using a
 * read-modify-write sequence, to avoid unintended effects on the state of the exception handlers.
 *
 * @note Removing the active state of an exception can change the current execution priority, and affect the exception
 * return consistency checks. If software removes the active state, causing a change in current execution priority, this
 * can defeat the architectural behavior that prevents an exception from preempting its own handler
 */
DEFINE_REG(SystemHandlerControlAndStateRegister, {
    bool MEMFAULTACT : 1;  ///< bit[0]
                           ///< MemManage is active if true

    bool BUSFAULTACT : 1;  ///< bit[1]
                           ///< BusFault is active if true

    RESERVE(1);  ///< bit[2]

    bool USGFAULTACT : 1;  ///< bit[1]
                           ///< UsageFault is active if true

    RESERVE(3);  ///< bits[6:4]

    bool SVCALLACT : 1;  ///< bit[7]
                         ///< SVCall is active if true

    bool MONITORACT : 1;  ///< bit[8]
                          ///< Monitor is active if true

    RESERVE(1);  ///< bit[9]

    bool PENDSVACT : 1;  ///< bit[10]
                         ///< PendSV is active if true

    bool SYSTICKACT : 1;  ///< bit[11]
                          ///< SysTick is active if true

    bool USGFAULTPENDED : 1;  ///< bit[12]
                              ///< UsageFault is pending if true

    bool MEMFAULTPENDED : 1;  ///< bit[13]
                              ///< MemManage is pending if true

    bool BUSFAULTPENDED : 1;  ///< bit[14]
                              ///< BusFault is pending if true

    bool SVCALLPENDED : 1;  ///< bit[15]
                            ///< SVCall is pending if true

    bool MEMFAULTENA : 1;  ///< bit[16]
                           ///< MemManage fault enabled if true

    bool BUSFAULTENA : 1;  ///< bit[17]
                           ///< BusFault enabled if true

    bool USGFAULTENA : 1;  ///< bit[18]
                           ///< UsageFault enabled if true

    RESERVE(13);  ///< bits[31:19]
});

/**
 * Shows the status of MPU faults.
 */
DEFINE_BYTEREG(MemManageStatusRegister, {
    bool IACCVIOL : 1;  ///< bit[0]
                        ///< If true: MPU or Execute Never (XN) default memory map access violation on an
                        ///< instruction fetch has occurred. The fault is signalled only if the instruction is
                        ///< issued.

    bool DACCVIOL : 1;  ///< bit[1]
                        ///< If true: Data access violation. The MMFAR shows the data address that the load or store
                        ///< tried to access

    RESERVE_BYTE(1);  ///< bit[2]

    bool MUNSTKERR : 1;  ///< bit[3]
                         ///< If true: A derived MemManage fault occurred on exception return

    bool MSTKERR : 1;  ///< bit[4]
                       ///< If true: A derived MemManage fault occurred on exception entry.

    bool MLSPERR : 1;  ///< bit[5]
                       ///< If true: A MemManage fault occurred during FP lazy state preservation.

    RESERVE_BYTE(1);  ///< bit[6]

    bool MMARVALID : 1;  ///< bit[7]
                         ///< MMFAR has valid contents if true
});

/**
 * Shows the status of bus errors resulting from instruction prefetches and data accesses.
 */
DEFINE_BYTEREG(BusFaultStatusRegister, {
    bool IBUSERR : 1;  ///< bit[0]
                       ///< If true: A bus fault on an instruction prefetch has occurred. The fault is signaled only if
                       ///< the instruction is issued.

    bool PRECISERR : 1;  ///< bit[1]
                         ///< If true: A precise data access error has occurred, and the processor has written the
                         ///< faulting address to the BFAR.

    bool IMPRECISERR : 1;  ///< bit[2]
                           ///< If true: Imprecise data access error has occurred.

    bool UNSTKERR : 1;  ///< bit[3]
                        ///< If true: A derived bus fault has occurred on exception return

    bool STKERR : 1;  ///< bit[4]
                      ///< If true: A derived bus fault has occurred on exception entry.

    bool LSPERR : 1;  ///< bit[5]
                      ///< If true: A bus fault occurred during FP lazy state preservation.

    RESERVE_BYTE(1);  ///< bit[6]

    bool BFARVALID : 1;  ///< bit[7]
                         ///< BFAR has valid contents if true
});

/**
 * Contains the status for some instruction execution faults, and for data access faults.
 */
DEFINE_HALFREG(UsageFaultStatusRegister, {
    bool UNDEFINSTR : 1;  ///< bit[0]
                          ///< If true: The processor has attempted to execute an undefined instruction. This might be  an
                          ///< undefined instruction associated with an enabled coprocessor

    bool INVSTATE : 1;  ///< bit[1]
                        ///< If true: Instruction executed with invalid EPSR.T or EPSR.IT field

    bool INVPC : 1;  ///< bit[2]
                     ///< If true: An integrity check error has occurred on EXC_RETURN.

    bool NOCP : 1;  ///< bit[3]
                    ///< If true: A coprocessor access error has occurred. This shows that the coprocessor is  disabled or
                    ///< not present.

    RESERVE_HW(4);  ///< bits[7:4]

    bool UNALIGNED_ : 1;  ///< bit[8]
                          ///< If true: Unaligned access error has occurred.
                          ///<
                          ///< Multi-word accesses always fault if not word aligned. Software can configure unaligned word
                          ///< and halfword accesses to fault, by enabling UNALIGN_TRP in the CCR

    bool DIVBYZERO : 1;  ///< bit[9]
                         ///< If true: Divide by zero error has occurred
                         ///<
                         ///< When SDIV or UDIV instruction is used with a divisor of 0, this fault occurs if DIV_0_TRP is
                         ///< enabled in the CCR

    RESERVE_HW(6);  ///< bits[15:10]
});

/**
 * Contains the three Configurable Fault Status Registers.
 */
DEFINE_REG(ConfigurableFaultStatusRegister, {
    MemManageStatusRegister memManage;  ///< bits[7:0]
                                        ///< Provides information on MemManage exceptions

    BusFaultStatusRegister busFault;  ///< bits[15:8]
                                      ///< Provides information on BusFault exceptions

    UsageFaultStatusRegister usageFault;  ///< bits[31:16]
                                          ///< Provides information on UsageFault exceptions
});

/**
 * Shows the cause of any HardFault
 */
DEFINE_REG(HardFaultStatusRegister, {
    RESERVE(1);  ///< bit[0]

    bool VECTTBL : 1;  ///< bit[1]
                       ///< Indicates when a fault has occurred because of a vector table read error on exception
                       ///< processing:
                       ///< false - no vector table read fault has occurred
                       ///< true - vector table read fault has occurred

    RESERVE(28);  ///< bits[7:2]

    bool FORCED : 1;  ///< bit[30]
                      ///< Indicates that a fault with configurable priority has been escalated to a HardFault exception,
                      ///< because it could not be made active, because of priority or because it was disabled:
                      ///< false - no priority escalation has occurred
                      ///< true - processor has escalated a configurable-priority exception to HardFault

    bool DEBUGEVT : 1;  ///< bit[31]
                        ///< Indicates when a Debug event has occurred:
                        ///< false - no Debug event has occurred
                        ///< true - Debug event has occurred. The Debug Fault Status Register has been updated
                        ///<
                        ///< The processor sets this bit to 1 only when halting debug is disabled and a Debug event occurs
});

/**
 * Shows the address of the memory location that caused an MPU fault.
 *
 * @note Valid only when MMFSR.MMARVALID is set
 */
DEFINE_REG(MemManageFaultAddressRegister, {
    uint32_t ADDRESS;  ///< bits[31:0]
                       ///< Data address for an MPU fault. This is the location addressed by an attempted load or store
                       ///< access that was faulted. The MemManage Status Register shows the cause of the fault, and
                       ///< whether MMFAR.ADDRESS is valid.When an unaligned access faults, the address is the  actual
                       ///< address that faulted. Because an access might be split into multiple parts, each aligned, this
                       ///< address can be any offset in the range of the requested size
});

/**
 * Shows the address associated with a precise data access fault.
 *
 * @note Valid only when BFSR.BFARVALID is set, otherwise reads as UNKNOWN
 */
DEFINE_REG(BusFaultAddressRegister, {
    uint32_t ADDRESS;  ///< bits[31:0]
                       ///< Data address for a precise bus fault. This is the location addressed by an attempted data
                       ///< access that was faulted. The BFSR shows the reason for the fault and whether BFAR.ADDRESS is
                       ///< valid
                       ///<
                       ///< For unaligned access faults, the value returned is the address requested by the instruction.
                       ///< This might not be the address that faulted
                       ///<
                       ///< In implementations without unique BFAR and MFAR registers, the value of this register is
                       ///< UNKNOWN if MFSR.MMFARVALID is set.
});

/**
 * Specifies additional system fault information to software.
 *
 * The AFSR flags map directly onto the AUXFAULT inputs of the processor, and a single-cycle high level on an external
 * pin causes the corresponding AFSR bit to become latched as one. The bit can only be cleared by writing a one to the
 * corresponding AFSR bit. When an AFSR bit is written or latched as one, an exception does not occur. To make use of
 * AUXFAULT input signals, software must poll the AFSR.
 *
 * @note This register is available in all processor configurations.
 */
DEFINE_REG(AuxiliaryFaultStatusRegister, {
    uint32_t AUXFAULT;  ///< bits[31:0]
                        ///< Latched version of the AUXFAULT inputs.
});

// TODO: move into another module
enum CoprocessorAccessPrivileges : uint8_t {
    AccessDenied = 0b00,          ///</< Any attempted access generates a NOCP UsageFault
    PrivilegedAccessOnly = 0b01,  ///< An unprivileged access generates a NOCP UsageFault
    // Reserved = 0b10,
    FullAccess = 0b11,
};

/**
 * Specifies the access privileges for coprocessors.
 */
DEFINE_REG(CoprocessorAccessControlRegister, {
    uint8_t CP0 : 2;   ///< bits[1:0]
    uint8_t CP1 : 2;   ///< bits[3:2]
    uint8_t CP2 : 2;   ///< bits[5:4]
    uint8_t CP3 : 2;   ///< bits[7:6]
    uint8_t CP4 : 2;   ///< bits[9:8]
    uint8_t CP5 : 2;   ///< bits[11:10]
    uint8_t CP6 : 2;   ///< bits[13:12]
    uint8_t CP7 : 2;   ///< bits[15:14]
    RESERVE(4);        ///< bits[19:16]
    uint8_t CP10 : 2;  ///< bits[21:20]
    uint8_t CP11 : 2;  ///< bits[23:22]
    RESERVE(8);        ///< bits[31:24]
});

/**
 * Provides information about the interrupt controller
 */
DEFINE_REG(InterruptControllerTypeRegister, {
    uint8_t INTLINESNUM : 4;  ///< bits[3:0]
                              ///< The total number of interrupt lines supported by an implementation, defined in groups
                              ///< of 32. That is, the total number of interrupt lines is up to (32*(INTLINESNUM+1)).
                              ///< However, the absolute maximum number of interrupts is 496, corresponding to the
                              ///< INTLINESNUM value 0b1111.

    RESERVE(28);  ///< bits[31:5]
});

/**
 * Disables certain aspects of functionality within the processor.
 *
 * @note This register is available in all processor configurations
 */
DEFINE_REG(AuxiliaryControlRegister, {
    bool DISMCYCINT : 1;  ///< bit[0]
                          ///< Disables interruption of multi-cycle instructions. This increases the interrupt latency of
                          ///< the processor because load/store and multiply/divide operations complete before interrupt
                          ///< stacking occurs.

    bool DISDEFWBUF : 1;  ///< bit[1]
                          ///< Disables write buffer use during default memory map accesses. This causes all bus faults to
                          ///< be precise, but decreases the performance of the processor because stores to memory must
                          ///< complete before the next instruction can be executed.

    bool DISFOLD : 1;  ///< bit[2]
                       ///< Disables folding of IT instructions.

uint8_t:
    5;  ///< bits[7:3]
        ///< Reserved

    bool DISFPCA : 1;  ///< bit[8]
                       ///< SBZP.

    bool DISOOFP : 1;  ///< bit[9]
                       ///< Disables floating point instructions completing out of order with respect to integer
                       ///< instructions.

    RESERVE(22);  ///< bits[31:10]
});

/**
 * Provides a mechanism for software to generate an interrupt.
 */
DEFINE_REG(SoftwareTriggeredInterruptRegister, {
    uint16_t INTID : 9;  ///< bits[8:0]
                         ///< Indicates the interrupt to be triggered. The value written is (ExceptionNumber - 16)
                         ///< Writing to this register has the same effect as setting the NVIC ISPR bit corresponding to
                         ///< the interrupt to 1

    RESERVE(23);  ///< bits[31:9]
});

}  // namespace stm32::rg
