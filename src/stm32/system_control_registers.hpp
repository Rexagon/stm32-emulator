#pragma once

#include <cstdint>

#ifdef UNALIGNED
#undef UNALIGNED
#endif

namespace stm32
{
/**
 * Specifies the ID number of the processor core, the version number of the processor core and the implementation
 * details of the processor core.
 *
 * @note This register is available in all processor configurations.
 */
struct __attribute__((__packed__)) CpuIdBaseRegister {
    uint8_t REVISION : 4;  // bits[3:0]
                           // Indicates patch release: 0x1 = Patch 1.

    uint16_t PARTNO : 12;  // bits[15:4]
                           // Indicates part number: 0xC24 = Cortex-M3

    uint8_t constant : 4;  // bits[19:16]
                           // Reads as 0xF

    uint8_t VARIANT : 4;  // bits[23:20]
                          // Indicates processor revision: 0x0 = Revision 0

    uint8_t IMPLEMENTER : 8;  // bits[31:24]
                              // Indicates implementer: 0x41 = ARM
};

/**
 * Provides software control of the NMI, PendSV, and SysTick exceptions, and provides interrupt status information.
 */
struct __attribute__((__packed__)) InterruptControlAndStateRegister {
    uint16_t VECTACTIVE : 9;  // bits[8:0], read only for memory
                              // The exception number of the current executing exception. A value of 0 indicates that
                              // the processor is in Thread mode.

    uint8_t : 2;  // bits[10:9]
    // Reserved

    bool RETTOBASE : 1;  // bit[11], read only for memory
                         // In Handler mode, indicates whether there is an active exception other than the exception
                         // indicated by the current value of the IPSR
                         //
                         // If true there is no active exception other than any exception shown by IPSR, there is an
                         // active exception other than the exception shown by IPSR otherwise
                         //
                         // In Thread mode the value of this bit is UNKNOWN


    uint16_t VECTPENDING : 9;  // bits[20:12], read only for memory
                               // The exception number of the highest priority pending and enabled interrupt. A value of
                               // 0 indicates that there is no pending exception
                               //
                               // If DHCSR.C_MASKINTS is set, then PendSV, SysTick, and configurable external interrupts
                               // are masked and will not be shown as pending in VECTPENDING

    uint8_t : 1;  // bit[21]
                  // Reserved

    bool ISRPENDING : 1;  // bit[22], read only for memory
                          // Indicates whether an external interrupt, generated by the NVIC, is pending

    bool ISRPREEMPT : 1;  // bit[23], read only for memory
                          // Indicates whether a pending exception will be serviced on exit from debug halt state

    uint8_t : 1;  // bit[24]
                  // Reserved

    bool PENDSTCLR : 1;  // bit[25], write only for memory
                         // Removes the pending status of the SysTick exception if true, has no effect otherwise

    bool PENDSTSET : 1;  // bit[26]
                         // On writes, sets the SysTick exception as pending. On reads, indicates the current state of
                         // the exception

    bool PENDSVCLR : 1;  // bit[27], write only for memory
                         // Removes the pending status of the PendSV exception if true, has no effect otherwise

    bool PENDSVSET : 1;  // bit[28]
                         // On writes, sets the PendSV exception as pending. On reads, indicates the current state of
                         // the exception
                         // Make PendSV exception pending if true, has no effect otherwise

    uint8_t : 2;  // bits[30:29]
                  // Reserved

    bool NMIPENDSET : 1;  // bit[31]
                          // On writes, makes the NMI exception active if true, has no effect otherwise
};

/**
 * Holds the vector table address.
 *
 * @note One or two of the high-order bits of the TBLOFF field can be implemented as RAZ/WI, reducing the supported
 * address range. For example, if two bits are implemented as RAZ/WI, then TBLOFF[29:7] defines bits[29:7] of the
 * address.
 *
 * @note Software can write all 1s to the TBLOFF field and then read the register to find the maximum supported offset
 * value.
 */
struct __attribute__((__packed__)) VectorTableOffsetRegister {
    uint8_t : 7;  // bits[6:0]
                  // Reserved

    uint32_t TBLOFF : 25;  // bits[31:7]
                           // Bits[31:7] of the vector table address
};

/**
 * Sets or returns interrupt control data.
 */
struct __attribute__((__packed__)) ApplicationInterruptAndResetControlRegister {
    bool VECTRESET : 1;  // bit[0], write only for memory
                         // Writing 1 to this bit causes a local system reset
                         // The effect of writing a 1 to this bit if the processor is not halted in Debug state is
                         // UNPREDICTABLE
                         // When the processor is halted in Debug state, if a write to the register writes a 1 to both
                         // VECTRESET and SYSRESETREQ, the behavior is UNPREDICTABLE.

    bool VECTCLRACTIVE : 1;  // bit[0], write only for memory
                             // Writing 1 to this bit clears all active state information for fixed and configurable
                             // exceptions.
                             // This includes clearing the IPSR to zero
                             // The effect of writing a 1 to this bit if the processor is not halted in Debug state is
                             // UNPREDICTABLE.

    bool SYSRESETREQ : 1;  // bit[2]
                           // Writing 1 to this bit asserts a signal to the external system to request a Local reset.
                           // A Local or Power-on reset clears this bit to 0.

    uint8_t : 5;  // bits[7:3]
                  // Reserved

    uint8_t PRIGROUP : 3;  // bits[10:8]
                           // Priority grouping, indicates the binary point position.
                           // This field resets to 0b000

    uint8_t : 4;  // bits[14:11]
                  // Reserved

    bool ENDIANNESS : 1;  // bit[15], read only for memory
                          // Indicates the memory system endianness
                          // This bit is static or configured by a hardware input on reset.

    // Vector key
    // uint16_t VECTKEY : 16 / uint16_t VECTKEYSTAT : 16
    // Register writes must write 0x05FA to this field, otherwise the write is ignored
    // Register reads returns 0xFA05

    static constexpr uint16_t VECTKEY = 0x05FA;
    static constexpr uint16_t VECTKEYSTAT = 0xFA05;
};

/**
 * Sets or returns system control data
 */
struct __attribute__((__packed__)) SystemControlRegister {
    uint8_t : 1;  // bit[0]
                  // Reserved

    bool SLEEPONEXIT : 1;  // bit[1]
                           // Determines whether, on an exit from an ISR that returns to the base level of execution
                           // priority, the processor enters a sleep state
                           // false - do not enter sleep state
                           // true - enter sleep state

    bool SLEEPDEEP : 1;  // bit[2]
                         // Provides a qualifying hint indicating that waking from sleep might take longer. An
                         // implementation can use this bit to select between two alternative sleep states:
                         // false - selected sleep state is not deep sleep.
                         // true - selected sleep state is deep sleep.
                         // Details of the implemented sleep states, if any, and details of the use of this bit, are
                         // IMPLEMENTATION DEFINED.
                         // If the processor does not implement a deep sleep state then this bit can be RAZ/WI

    uint8_t : 1;  // bit[3]
                  // Reserved

    bool SEVONPEND : 1;  // bit[4]
                         // Determines whether an interrupt transition from inactive state to pending state is a wakeup
                         // event:
                         // false - transitions from inactive to pending are not wakeup events
                         // true - transitions from inactive to pending are wakeup events

    uint32_t : 27;  // bits[31:5]
                    // Reserved
};

/**
 * Sets or returns configuration and control data, and provides control over caching and branch prediction.
 */
struct __attribute__((__packed__)) ConfigurationAndControlRegister {
    bool NONBASETHRDENA : 1;  // bit[0]
                              // Controls whether the processor can enter Thread mode with exceptions active:
                              // false - any attempt to enter Thread mode with exceptions active faults.
                              // true - The processor can enter Thread mode with exceptions active because of a
                              // controlled return value

    bool USERSETMPEND : 1;  // bit[1]
                            // Controls whether unprivileged software can access the STIR:
                            // false - unprivileged software cannot access the STIR.
                            // true - unprivileged software can access the STIR.

    uint8_t : 1;  // bit[2]
                  // Reserved

    bool UNALIGN_TRP : 1;  // bit[3]
                           // Controls the trapping of unaligned word or halfword accesses:
                           // false - trapping disabled
                           // true - trapping enabled
                           // Unaligned load-store multiples and word or halfword exclusive accesses always fault

    bool DIV_0_TRP : 1;  // bit[4]
                         // Controls the trap on divide by 0:
                         // false - trapping disabled
                         // true - trapping enabled

    uint8_t : 3;  // bits[7:5]
                  // Reserved

    bool BFHFNMIGN : 1;  // bit[8]
                         // Determines the effect of precise data access faults on handlers running at priority -1 or
                         // priority -2:
                         // false - precise data access fault causes a lockup
                         // true - handler ignores the fault

    bool STKALIGN : 1;  // bit[9]
                        // Determines whether the exception entry sequence guarantees 8-byte stack frame alignment,
                        // adjusting the SP if necessary before saving state:
                        // false - guaranteed SP alignment is 4-byte, no SP adjustment is performed
                        // true - 8-byte alignment guaranteed, SP adjusted if necessary.
                        // The reset value of this bit is 1

    uint8_t : 6;  // bits[15:10]
                  // Reserved

    bool DC : 1;  // bit[16]
                  // Cache enable bit. This is a global enable bit for data and unified caches. The possible values
                  // of this bit are:
                  // false - data and unified caches disabled
                  // true - data and unified caches enabled
                  //
                  // If the system does not implement any data or unified caches that can be accessed by the
                  // processor at any level of the memory hierarchy, this bit is RAZ/WI
                  //
                  // If the system implements any data or unified caches that can be accessed by the processor
                  // then it must be possible to disable them by setting this bit to false

    bool IC : 1;  // bit[17]
                  // Instruction cache enable bit. This is a global enable bit for instruction caches. The possible
                  // values of this bit are:
                  // false - instruction caches disabled
                  // true - instruction caches enabled
                  //
                  // If the system does not implement any instruction caches that can be accessed by the
                  // processor at any level of the memory hierarchy, this bit is RAZ/WI.
                  //
                  // If the system implements any instruction caches that can be accessed by the processor then
                  // it must be possible to disable them by setting this bit to false.

    bool BP : 1;  // bit[18]
                  // Branch prediction enable bit. The possible values of this bit are:
                  // false - program flow prediction disabled.
                  // true - program flow prediction enabled.
                  //
                  // Setting this bit to 1 enables branch prediction, also called program flow prediction
                  //
                  // If program flow prediction cannot be disabled, this bit is RAO/WI.
                  //
                  // If the implementation does not support program flow prediction, this bit is RAZ/WI.

    uint16_t : 13;  // bits[31:19]
                    // Reserved
};

/**
 * Sets or returns priority for system handlers
 */
struct __attribute__((__packed__)) SystemHandlerPriorityRegister {
    uint8_t PRI[4];
};

/**
 * Controls and provides the active and pending status of system exceptions.
 *
 * @note Exception processing automatically updates the SHCSR fields. However, software can write to the register to add
 * or remove the pending or active state of an exception. When updating the SHCSR, ARM recommends using a
 * read-modify-write sequence, to avoid unintended effects on the state of the exception handlers.
 *
 * @note Removing the active state of an exception can change the current execution priority, and affect the exception
 * return consistency checks. If software removes the active state, causing a change in current execution priority, this
 * can defeat the architectural behavior that prevents an exception from preempting its own handler
 */
struct __attribute__((__packed__)) SystemHandlerControlAndStateRegister {
    bool MEMFAULTACT : 1;  // bit[0]
                           // MemManage is active if true

    bool BUSFAULTACT : 1;  // bit[1]
                           // BusFault is active if true

    uint8_t : 1;  // bit[2]
                  // Reserved

    bool USGFAULTACT : 1;  // bit[1]
                           // UsageFault is active if true

    uint8_t : 3;  // bits[6:4]
                  // Reserved

    bool SVCALLACT : 1;  // bit[7]
                         // SVCall is active if true

    bool MONITORACT : 1;  // bit[8]
                          // Monitor is active if true

    uint8_t : 1;  // bit[9]
                  // Reserved

    bool PENDSVACT : 1;  // bit[10]
                         // PendSV is active if true

    bool SYSTICKACT : 1;  // bit[11]
                          // SysTick is active if true

    bool USGFAULTPENDED : 1;  // bit[12]
                              // UsageFault is pending if true

    bool MEMFAULTPENDED : 1;  // bit[13]
                              // MemManage is pending if true

    bool BUSFAULTPENDED : 1;  // bit[14]
                              // BusFault is pending if true

    bool SVCALLPENDED : 1;  // bit[15]
                            // SVCall is pending if true

    bool MEMFAULTENA : 1;  // bit[16]
                           // MemManage fault enabled if true

    bool BUSFAULTENA : 1;  // bit[17]
                           // BusFault enabled if true

    bool USGFAULTENA : 1;  // bit[18]
                           // UsageFault enabled if true

    uint16_t : 13;  // bits[31:19]
                    // Reserved
};

/**
 * Shows the status of MPU faults.
 */
struct __attribute__((__packed__)) MemManageStatusRegister {
    bool IACCVIOL : 1;  // bit[0]
                        // If true: MPU or Execute Never (XN) default memory map access violation on an
                        // instruction fetch has occurred. The fault is signalled only if the instruction is
                        // issued.

    bool DACCVIOL : 1;  // bit[1]
                        // If true: Data access violation. The MMFAR shows the data address that the load or store
                        // tried to access

    uint8_t : 1;  // bit[2]
                  // Reserved

    bool MUNSTKERR : 1;  // bit[3]
                         // If true: A derived MemManage fault occurred on exception return

    bool MSTKERR : 1;  // bit[4]
                       // If true: A derived MemManage fault occurred on exception entry.

    bool MLSPERR : 1;  // bit[5]
                       // If true: A MemManage fault occurred during FP lazy state preservation.

    uint8_t : 1;  // bit[6]
                  // Reserved

    bool MMARVALID : 1;  // bit[7]
                         // MMFAR has valid contents if true
};

/**
 * Shows the status of bus errors resulting from instruction prefetches and data accesses.
 */
struct __attribute__((__packed__)) BusFaultStatusRegister {
    bool IBUSERR : 1;  // bit[0]
                       // If true: A bus fault on an instruction prefetch has occurred. The fault is signaled only if
                       // the instruction is issued.

    bool PRECISERR : 1;  // bit[1]
                         // If true: A precise data access error has occurred, and the processor has written the
                         // faulting address to the BFAR.

    bool IMPRECISERR : 1;  // bit[2]
                           // If true: Imprecise data access error has occurred.

    bool UNSTKERR : 1;  // bit[3]
                        // If true: A derived bus fault has occurred on exception return

    bool STKERR : 1;  // bit[4]
                      // If true: A derived bus fault has occurred on exception entry.

    bool LSPERR : 1;  // bit[5]
                      // If true: A bus fault occurred during FP lazy state preservation.

    uint8_t : 1;  // bit[6]
                  // Reserved

    bool BFARVALID : 1;  // bit[7]
                         // BFAR has valid contents if true
};

/**
 * Contains the status for some instruction execution faults, and for data access faults.
 */
struct __attribute__((__packed__)) UsageFaultStatusRegister {
    bool UNDEFINSTR : 1;  // bit[0]
                          // If true: The processor has attempted to execute an undefined instruction. This might be  an
                          // undefined instruction associated with an enabled coprocessor

    bool INVSTATE : 1;  // bit[1]
                        // If true: Instruction executed with invalid EPSR.T or EPSR.IT field

    bool INVPC : 1;  // bit[2]
                     // If true: An integrity check error has occurred on EXC_RETURN.

    bool NOCP : 1;  // bit[3]
                    // If true: A coprocessor access error has occurred. This shows that the coprocessor is  disabled or
                    // not present.

    uint8_t : 4;  // bits[7:4]
                  // Reserved

    bool UNALIGNED : 1;  // bit[8]
                         // If true: Unaligned access error has occurred.
                         //
                         // Multi-word accesses always fault if not word aligned. Software can configure unaligned word
                         // and halfword accesses to fault, by enabling UNALIGN_TRP in the CCR

    bool DIVBYZERO : 1;  // bit[9]
                         // If true: Divide by zero error has occurred
                         //
                         // When SDIV or UDIV instruction is used with a divisor of 0, this fault occurs if DIV_0_TRP is
                         // enabled in the CCR

    uint8_t : 6;  // bits[15:10]
                  // Reserved
};

/**
 * Contains the three Configurable Fault Status Registers.
 */
struct __attribute__((__packed__)) ConfigurableFaultStatusRegister {
    MemManageStatusRegister memManage;  // bits[7:0]
                                        // Provides information on MemManage exceptions

    BusFaultStatusRegister busFault;  // bits[15:8]
                                      // Provides information on BusFault exceptions

    UsageFaultStatusRegister usageFault;  // bits[31:16]
                                          // Provides information on UsageFault exceptions
};

/**
 * Shows the cause of any HardFault
 */
struct __attribute__((__packed__)) HardFaultStatusRegister {
    uint8_t : 1;  // bit[0]
                  // Reserved

    bool VECTTBL : 1;  // bit[1]
                       // Indicates when a fault has occurred because of a vector table read error on exception
                       // processing:
                       // false - no vector table read fault has occurred
                       // true - vector table read fault has occurred

    uint32_t : 28;  // bits[7:2]
                    // Reserved

    bool FORCED : 1;  // bit[30]
                      // Indicates that a fault with configurable priority has been escalated to a HardFault exception,
                      // because it could not be made active, because of priority or because it was disabled:
                      // false - no priority escalation has occurred
                      // true - processor has escalated a configurable-priority exception to HardFault

    bool DEBUGEVT : 1;  // bit[31]
                        // Indicates when a Debug event has occurred:
                        // false - no Debug event has occurred
                        // true - Debug event has occurred. The Debug Fault Status Register has been updated
                        //
                        // The processor sets this bit to 1 only when halting debug is disabled and a Debug event occurs
};

/**
 * Shows the address of the memory location that caused an MPU fault.
 *
 * @note Valid only when MMFSR.MMARVALID is set
 */
struct __attribute__((__packed__)) MemManageFaultAddressRegister {
    uint32_t ADDRESS;  // bits[31:0]
                       // Data address for an MPU fault. This is the location addressed by an attempted load or store
                       // access that was faulted. The MemManage Status Register shows the cause of the fault, and
                       // whether MMFAR.ADDRESS is valid.When an unaligned access faults, the address is the  actual
                       // address that faulted. Because an access might be split into multiple parts, each aligned, this
                       // address can be any offset in the range of the requested size
};

/**
 * Shows the address associated with a precise data access fault.
 *
 * @note Valid only when BFSR.BFARVALID is set, otherwise reads as UNKNOWN
 */
struct __attribute__((__packed__)) BusFaultAddressRegister {
    uint32_t ADDRESS;  // bits[31:0]
                       // Data address for a precise bus fault. This is the location addressed by an attempted data
                       // access that was faulted. The BFSR shows the reason for the fault and whether BFAR.ADDRESS is
                       // valid
                       //
                       // For unaligned access faults, the value returned is the address requested by the instruction.
                       // This might not be the address that faulted
                       //
                       // In implementations without unique BFAR and MFAR registers, the value of this register is
                       // UNKNOWN if MFSR.MMFARVALID is set.
};

/**
 * Specifies additional system fault information to software.
 *
 * The AFSR flags map directly onto the AUXFAULT inputs of the processor, and a single-cycle high level on an external
 * pin causes the corresponding AFSR bit to become latched as one. The bit can only be cleared by writing a one to the
 * corresponding AFSR bit. When an AFSR bit is written or latched as one, an exception does not occur. To make use of
 * AUXFAULT input signals, software must poll the AFSR.
 *
 * @note This register is available in all processor configurations.
 */
struct __attribute__((__packed__)) AuxiliaryFaultStatusRegister {
    uint32_t AUXFAULT;  // bits[31:0]
                        // Latched version of the AUXFAULT inputs.
};

/**
 * Specifies the access privileges for coprocessors.
 */
struct __attribute__((__packed__)) CoprocessorAccessControlRegister {
    enum Privileges : uint8_t {
        AccessDenied = 0b00,          // Any attempted access generates a NOCP UsageFault
        PrivilegedAccessOnly = 0b01,  // An unprivileged access generates a NOCP UsageFault
        // Reserved = 0b10,
        FullAccess = 0b11,
    };

    uint8_t CP0 : 2;  // bits[1:0]
    uint8_t CP1 : 2;  // bits[3:2]
    uint8_t CP2 : 2;  // bits[5:4]
    uint8_t CP3 : 2;  // bits[7:6]
    uint8_t CP4 : 2;  // bits[9:8]
    uint8_t CP5 : 2;  // bits[11:10]
    uint8_t CP6 : 2;  // bits[13:12]
    uint8_t CP7 : 2;  // bits[15:14]

    uint8_t : 4;  // bits[19:16]
                  // Reserved

    uint8_t CP10 : 2;  // bits[21:20]
    uint8_t CP11 : 2;  // bits[23:22]

    uint8_t : 8;  // bits[31:24]
                  // Reserved
};

// TODO: add Floating Point Context Control Register
// TODO: add Floating Point Context Address Register
// TODO: add Floating Point Default Status Control Register

/**
 * Provides information about the interrupt controller
 */
struct __attribute__((__packed__)) InterruptControllerTypeRegister {
    uint8_t INTLINESNUM : 4;  // bits[3:0]
                              // The total number of interrupt lines supported by an implementation, defined in groups
                              // of 32. That is, the total number of interrupt lines is up to (32*(INTLINESNUM+1)).
                              // However, the absolute maximum number of interrupts is 496, corresponding to the
                              // INTLINESNUM value 0b1111.

    uint32_t : 28;  // bits[31:5]
                    // Reserved
};

/**
 * Disables certain aspects of functionality within the processor.
 *
 * @note This register is available in all processor configurations
 */
struct __attribute__((__packed__)) AuxiliaryControlRegister {
    bool DISMCYCINT : 1;  // bit[0]
                          // Disables interruption of multi-cycle instructions. This increases the interrupt latency of
                          // the processor because load/store and multiply/divide operations complete before interrupt
                          // stacking occurs.

    bool DISDEFWBUF : 1;  // bit[1]
                          // Disables write buffer use during default memory map accesses. This causes all bus faults to
                          // be precise, but decreases the performance of the processor because stores to memory must
                          // complete before the next instruction can be executed.

    bool DISFOLD : 1;  // bit[2]
                       // Disables folding of IT instructions.

    uint8_t : 5;  // bits[7:3]
                  // Reserved

    bool DISFPCA : 1;  // bit[8]
                       // SBZP.

    bool DISOOFP : 1;  // bit[9]
                       // Disables floating point instructions completing out of order with respect to integer
                       // instructions.

    uint32_t : 22;  // bits[31:10]
                    // Reserved
};

/**
 * Provides a mechanism for software to generate an interrupt.
 */
struct __attribute__((__packed__)) SoftwareTriggeredInterruptRegister {
    uint16_t INTID : 9;  // bits[8:0]
                         // Indicates the interrupt to be triggered. The value written is (ExceptionNumber - 16)
                         // Writing to this register has the same effect as setting the NVIC ISPR bit corresponding to
                         // the interrupt to 1

    uint32_t : 23;  // bits[31:9]
                    // Reserved
};

/**
 * SysTick Control and Status Register
 *
 * Controls the system timer and provides status data
 */
struct __attribute__((__packed__)) SysTickControlAndStatusRegister {
    bool ENABLE : 1;  // bit[0]
                      // Indicates the enabled status of the SysTick counter
                      // true - counter is operating
                      // false - counter is disabled

    bool TICKINT : 1;  // bit[1]
                       // Indicates whether counting to 0 causes the status of the SysTick exception to change to
                       // pending
                       // true - count to 0 changes the SysTick exception status to pending
                       // false - count to 0 does not affect the SysTick exception status

    uint8_t CLKSOURCE : 1;  // bit[2]
                            // Indicates the SysTick clock source:
                            // 1 - SysTick uses the processor clock
                            // 0 - SysTick uses the IMPLEMENTATION DEFINED external reference clock

    uint16_t : 13;  // bits[15:3]
                    // Reserved

    bool COUNTFLAG : 1;  // bit[16]
                         // Indicates whether the counter has counted to 0 since the last read of this register
                         // true - timer has counted to 0
                         // false - timer has not counted to 0
                         // Note: COUNTFLAG is set to 1 by a count transition from 1 to 0
                         // Note: COUNTFLAG is cleared to 0 by a software read of this register, and by and write to the
                         // Current Value register
                         // This bit is read only!

    uint16_t : 15;  // bits[31:17]
                    // Reserved
};

/**
 * SysTick Reload Value Register
 *
 * Holds the reload value of the SYST_CVR
 */
struct __attribute__((__packed__)) SysTickReloadValueRegister {
    uint32_t RELOAD : 24;  // bits[23:0]
                           // The value to load into the SYST_CVR when the counter reaches 0.

    uint8_t : 8;  // bits[31:24]
                  // Reserved (read - all zero)
};

/**
 * SysTick Current Value Register
 *
 * Reads or clears the current counter value
 */
struct __attribute__((__packed__)) SysTickCurrentValueRegister {
    uint32_t CURRENT : 32;  // bits[31:0]
                            // Current counter value
                            // This is the value of the counter at the time it is sampled
};

/**
 * SysTick Calibration value Register
 *
 * Reads the calibration value and parameters for SysTick
 */
struct __attribute__((__packed__)) SysTickCalibrationValueRegister {
    uint32_t TENMS : 24;  // bits[23:0]
                          // Optionally, holds a reload value to be used for 10ms (100Hz) timing, subject to system
                          // clock skew errors. If this field is zero, the calibration value is not known.

    uint8_t : 6;  // bits[29:24]
                  // Reserved

    bool SKEW : 1;  // bit[30]
                    // Indicated whether the 10ms calibration value is exact
                    // true - 10ms calibration value is INEXACT, because of the clock frequency
                    // false - 10ms calibration value is exact

    bool NOREF : 1;  // bit[31]
                     // Indicated whether the IMPLEMENTATION DEFINED reference clock is implemented:
                     // true - the reference clock is not implemented
                     // false - the reference clock is implemented
};

class SystemControlRegistersSet {
public:
    explicit SystemControlRegistersSet();

    void reset();

    inline auto CPUID() const -> const CpuIdBaseRegister& { return m_cpuIdBaseRegister; }
    inline auto ICSR() const -> const InterruptControlAndStateRegister& { return m_interruptControlAndStateRegister; }
    inline auto VTOR() const -> const VectorTableOffsetRegister& { return m_vectorTableOffsetRegister; }
    inline auto AIRCR() const -> const ApplicationInterruptAndResetControlRegister&
    {
        return m_applicationInterruptAndResetControlRegister;
    }
    inline auto SCR() const -> const SystemControlRegister& { return m_systemControlRegister; }
    inline auto CCR() const -> const ConfigurationAndControlRegister& { return m_configurationAndControlRegister; }

    inline auto SHPR1() const -> const SystemHandlerPriorityRegister& { return m_systemHandlerPriorityRegisters[0]; }
    inline auto SHPR2() const -> const SystemHandlerPriorityRegister& { return m_systemHandlerPriorityRegisters[1]; }
    inline auto SHPR3() const -> const SystemHandlerPriorityRegister& { return m_systemHandlerPriorityRegisters[2]; }
    inline auto SHCSR() const -> const SystemHandlerControlAndStateRegister& { return m_systemHandlerControlAndStateRegister; }

    inline auto CFSR() const -> const ConfigurableFaultStatusRegister& { return m_configurableFaultStatusRegister; }
    inline auto MMFSR() const -> const MemManageStatusRegister& { return m_configurableFaultStatusRegister.memManage; }
    inline auto BFSR() const -> const BusFaultStatusRegister& { return m_configurableFaultStatusRegister.busFault; }
    inline auto UFSR() -> UsageFaultStatusRegister& { return m_configurableFaultStatusRegister.usageFault; }
    inline auto UFSR() const -> const UsageFaultStatusRegister& { return m_configurableFaultStatusRegister.usageFault; }
    inline auto HFSR() const -> const HardFaultStatusRegister& { return m_hardFaultStatusRegister; }
    inline auto AFSR() const -> const AuxiliaryFaultStatusRegister& { return m_auxiliaryFaultStatusRegister; }

    inline auto MMFAR() const -> const MemManageFaultAddressRegister& { return m_memManageFaultAddressRegister; }
    inline auto BFAR() const -> const BusFaultAddressRegister& { return m_busFaultAddressRegister; }

    inline auto CPACR() const -> const CoprocessorAccessControlRegister& { return m_coprocessorAccessControlRegister; }

    inline auto ICTR() const -> const InterruptControllerTypeRegister& { return m_interruptControllerTypeRegister; }
    inline auto ACTLR() const -> const AuxiliaryControlRegister& { return m_auxiliaryControlRegister; }

    inline auto STIR() const -> const SoftwareTriggeredInterruptRegister& { return m_softwareTriggeredInterruptRegister; }

    inline auto SYST_CSR() const -> const SysTickControlAndStatusRegister& { return m_sysTickControlAndStatusRegister; }
    inline auto SYST_RVR() const -> const SysTickReloadValueRegister& { return m_sysTickReloadValueRegister; }
    inline auto SYST_CVR() const -> const SysTickCurrentValueRegister& { return m_sysTickCurrentValueRegister; }
    inline auto SYST_CALIB() const -> const SysTickCalibrationValueRegister& { return m_sysTickCalibrationValueRegister; }

private:
    CpuIdBaseRegister m_cpuIdBaseRegister;
    InterruptControlAndStateRegister m_interruptControlAndStateRegister;
    VectorTableOffsetRegister m_vectorTableOffsetRegister;
    ApplicationInterruptAndResetControlRegister m_applicationInterruptAndResetControlRegister;
    SystemControlRegister m_systemControlRegister;
    ConfigurationAndControlRegister m_configurationAndControlRegister;

    SystemHandlerPriorityRegister m_systemHandlerPriorityRegisters[3];
    SystemHandlerControlAndStateRegister m_systemHandlerControlAndStateRegister;

    ConfigurableFaultStatusRegister m_configurableFaultStatusRegister;
    HardFaultStatusRegister m_hardFaultStatusRegister;
    AuxiliaryFaultStatusRegister m_auxiliaryFaultStatusRegister;

    MemManageFaultAddressRegister m_memManageFaultAddressRegister;
    BusFaultAddressRegister m_busFaultAddressRegister;

    CoprocessorAccessControlRegister m_coprocessorAccessControlRegister;
    AuxiliaryControlRegister m_auxiliaryControlRegister;

    InterruptControllerTypeRegister m_interruptControllerTypeRegister;

    SoftwareTriggeredInterruptRegister m_softwareTriggeredInterruptRegister;

    SysTickControlAndStatusRegister m_sysTickControlAndStatusRegister;
    SysTickReloadValueRegister m_sysTickReloadValueRegister;
    SysTickCurrentValueRegister m_sysTickCurrentValueRegister;
    SysTickCalibrationValueRegister m_sysTickCalibrationValueRegister;
};

}  // namespace stm32
